# 문제: 11066(파일합치기)

소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.

예를 들어, C1, C2, C3, C4가 연속적인 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.

소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.

## 입력

프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 500)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.

## 출력

프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.

## 해결방법

두 파일을 합치는 데 필요한 비용의 합을 계속해서 총 비용에 더한 후 그 결과가 최소가 되어야 하는 문제이다.

총 비용이 최소가 되기 위해서는 현재까지 구한 모든 비용중에 가장 작은 두개의 값을 찾아서 서로 더한 후, 그 더한 값을 데이터에 추가해야한다.

왜냐하면 총 비용을 구하는 과정에서 중복으로 가산되는 데이터가 있고, 어떤 데이터를 중복시킬 건지 선택하는 것의 반복이기 때문이다.
```
예시
x1 = c1 + c2 (가장 작은 두개: c1과 c2)
x2 = c3 + c4 (가장 작은 두개: c3와 c4, x1 > c3,c4)

y = x1 + x2 = c1 + c2 + c3 +c4,  총비용 = 2c1+ 2c2 + 2c3 + 2c4

x1 = c1 + c2  (가장 작은 두개: c1과 c2)
x2 = x1 + c3  (가장 작은 두개: x1과 c3, c4 > x1,c3)
y = x3 = x2 + c4

y = c1 + c2 + (c1 + c2) + c3 + (c1+c2+c3) + c4

총비용 = 3c1 + 3c2 + 2c3 + c4,   c4 > (c1 + c2) 인 경우 이쪽이 더 작게된다.
```

즉 매번 가장 작은 두개의 값을 더해가면서 총 비용을 구한다.

그러면 우선순위 큐를 써야한다고 착각할 수 있는데 문제를 잘 읽어보면 여러 장들이 연속이 되어야 한다고 쓰여있다. 

생각해보면 소설을 페이지별로 쓰는 것이고 그것을 합치는 과정이니 당연한 말이다.

그러므로 합칠 때 정렬을 통해서 순서를 바꿔선 안된다. 

이렇게 되면 강제적으로 더해지는 순서가 정해지게 되니 그리디로 풀 수가 없게 된다.

그리디하게 풀려고 해도 강제적으로 몇개의 요소가 달라지게 되고 그것때문에 최적해가 아니게 될 수 있다.

예 : 40, 30, 30, 50

그리디: 60 + 90 + 150 = 300 

두 원소가 연속해야하는 경우 그리디: 60+100+150=310

실제 최적해: 70+80+150=300

그러므로 문제를 풀기 위해선 모든 구간합을 탐색하고 그 값을 기억할 필요가 있다.

```
c1+c2, c2+c3 , c3+c4, ...을 모두 구한다.

(1,2), (2,3) , (3,4) , ...에 저장

c1부터 c3까지의 가능한 합 순서는 c1+(c2+c3) , (c1+c2) + c3 둘중에 하나이다.
((c1+c3)+c2는 연속되지않아 불가능함에 유의)

각 비용은 c1 + 2(c2+c3), 2(c1+c2) + c3이다. 이중에 작은 값이 선택된다.

이 값을 (1,3)에 저장, (2,4), (3,5), ... 도 반복

즉 가능한 모든 합 순서에서 비용이 가장 작게 나오는 것으로 초기화

이를 (1,k)까지 반복하면 된다.

점화식:

sum[i] = i까지의 누적합 즉 sum[j] - sum[i-1]은 i부터 j까지의 합

dp[i][j] = MAXVAL

dp[i,j] = min(dp[i][j],dp[i][m] + dp[m+1][j] + sum[j] - sum[i-1]

이때 m은 i<= m <= j인 값이고 i가 1증가하면 j도 1증가하고,
j-i는 처음에는 2이며 j > k일때 i=1로 다시 시작함과 동시에 j-i는 1증가
```

## 복잡도

시간복잡도: 페이지의 길이 len = j-i = 2,3,4,....k 

각 m = i부터 j까지 페이지 길이만큼 반복함

이때 i=1부터 i + len <= k 일때까지 i를 1씩증가 k-len

1<= len<=k , Σ(k-len) * len = k(k+1)(k-1)/6 

즉 시간복잡도는 o(k^3)

공간복잡도: dp테이블 o(k^2)