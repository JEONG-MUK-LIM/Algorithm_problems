# 문제: 1029(그림교환)

예술을 사랑하는 사람들이 시장에 모여서 그들의 그림을 서로 거래하려고 한다. 모든 그림의 거래는 다음과 같은 조건을 만족해야 한다.

그림을 팔 때, 그림을 산 가격보다 크거나 같은 가격으로 팔아야 한다.
같은 그림을 두 번 이상 사는 것은 불가능하다.
방금 시장에 새로운 그림이 들어왔다. 1번 아티스트는 그 그림을 외부 상인에게 가격 0을 주고 샀다. 이제 그 그림을 자신의 예술가 친구들에게 팔려고 한다. 위의 조건을 모두 만족하는 거래만 이루어진다고 가정했을 때, 그림을 소유했던 사람의 수의 최댓값을 출력하는 프로그램을 작성하시오. (1번 아티스트와 마지막으로 그 그림을 소유한 사람도 포함한다).

## 입력

첫째 줄에 예술가의 수 N이 주어진다. N은 2보다 크거나 같고, 15보다 작거나 같은 자연수이다.

둘째 줄부터 N개의 줄에는 N개의 수가 주어진다. i번째 줄의 j번째 수는 j번 예술가가 i번 예술가에게 그 그림을 살 때의 가격이다. 모든 가격은 0이 제일 낮은 가격이고, 9가 제일 높은 가격이다.

## 출력

첫째 줄에 그 그림을 소유 했던 사람들 (잠시라도 소유했던 사람도 포함)의 최댓값을 출력한다.

## 해결방법

백트래킹으로 모든 경우를 탐색하려고 하면 n = 15이고

나머지 14명을 하나씩 나열하는 경우를 모두 탐색하면 14! = 870억

시간을 초과하게 된다.

그러므로 dp를 활용해야 하는데

이미 방문한 것에 대해 일일히 for문을 돌면 그만큼 복잡도가 늘어나게 된다.

이 문제에서는 방문 순서는 정해져 있지 않으므로 매번 모든 노드들의 방문을 체크해야하는데 이로인해 복잡도가 크게 늘어나게 된다.

여기서 비트마스킹 이라는 기법을 사용해야한다.

<br/>

비트마스킹이란 현재 방문한 것들(다시 방문 하지 않을 것들)을 for문으로 체크하는 게 아니고

이진수 비트(하나의 숫자)로 저장해두는 것이다.

예를 들어 16개의 점이 있으면 0000 0000 0000 0000에서 각 점이 0이면 방문 X , 1이면 방문 O로 방문여부를 판단하게 될 수 있다.

이때 문제의 범위인 15라면 2^15 = 32768 크기의 추가 메모리가 필요하게 된다.

그리고 dp와 함께 조합해서 사용한다.

```
사용 예시 
mask = mask | (1 << i);   i번째 비트를 1로 만든다. 1을 i번 좌측시프트하면 해당 자리수의 숫자를 다룰 수 있다.

mask = mask & ~(1 << i);  // i번째 비트를 0으로 만든다
if (mask & (1 << i)) { ... }  // i번째 비트가 1이면 true

```

<br/>
dp[cur][mask][cost]에 값을 다음과 같이 집어넣는다.

cur = 현재 사람에서 시작했을 때

mask = 현재 방문상태

cost = 현재 사람이 이전에 산 그림의 가격

일때 앞으로 그림을 가질 수 있는 최대 사람의 수이다.

이때 dp를 bottom up으로 채워나가서 dp[1][1<<1][0]에 최적해 값을 넣을 수 있도록 재귀로 탐색한다. 

## 복잡도

dp를 모두 채우는 경우이므로 그 크기만큼의 반복을 하게된다.

cur = n, mask = 2^n, cost = k   , 복잡도 o(n*2^n * k)