# 문제: 1082(방 번호)

스타트링크가 입주한 사무실은 방 번호를 직접 정할 수 있다. 방 번호를 정하려면 1층 문방구에서 파는 숫자를 구매해야 한다. 숫자를 구매하기 위해 준비한 금액은 M원이다.

문방구에서 파는 숫자는 0부터 N-1까지이고, 각 숫자 i의 가격은 Pi이다. 문방구에서는 같은 숫자를 여러 개 구매할 수 있고, 문방구는 매우 많은 재고를 보유하고 있기 때문에, 항상 원하는 만큼 숫자를 구매할 수 있다. 방 번호가 0이 아니라면 0으로 시작할 수 없다.

예를 들어, N = 3, M = 21, P0 = 6, P1 = 7, P2 = 8이라면, 만들 수 있는 가장 큰 방 번호는 210이다. 최대 M원을 사용해서 만들 수 있는 가장 큰 방 번호를 구해보자.

## 입력

첫째 줄에 N이 주아진다. 둘째 줄에는 공백으로 구분된 P0, ..., PN-1이 주어진다. 마지막 줄에는 M이 주어진다.

1 ≤ N ≤ 10
1 ≤ Pi ≤ 50
1 ≤ M ≤ 50
N, Pi, M은 정수

## 출력

첫째 줄에 최대 M원을 사용해서 만들 수 있는 가장 큰 방 번호를 출력한다. 적어도 하나의 숫자를 살 수 있는 입력만 주어진다.

## 해결방법

처음에 푼 풀이는 다음과 같다.

dp[p][m] 는  숫자들을 내림차순 정렬한 벡터

이때 각 숫자는 0부터 n-1까지 들어 갈 수 있다.

이 벡터안에 0,1,2 이 들어가 있으면 dp[p][m]으로 만들 수 있는 가장 큰 숫자는 211이 된다는 의미로 사용한다.

p은 구매한 숫자의 개수( <= 만들 수 있는 최대 숫자의 길이)이고, m은 입력으로 주어진 낼 수 있는 가격이다.

이때 dp[i][j]를 이용해서 dp[i+1][j + cost[k]] 를 구성할 수 있다. (k를 선택 시)

또한 어떠한 것도 선택하지 않는다는 선택지도 있으므로 dp[i+1][j] = dp[i][j]가 되도록한다.

그리고 dp[i][j]내의 선택된 숫자들을 정렬하고 k를 dp[i][j]를 복사한 벡터에 추가하고, 내림차순 정렬하면 0번 인덱스부터 가장 높은 자리의 자리수가 나올 것이다.

이때 0번인덱스에 0번이 들어가는 경우는 제외한다 (즉 dp[i][j]가 비어있고 k=0일때)

그것을 기존의 dp[i+1][j+cost[k]]에 대소비교 후 더 큰 값을 갖는다면 업데이트 해주면서 

dp[L][m]에 가장 큰 숫자가 올 수 있도록 만들어준다.

<br/>

그러나 이 방법은 비효율적이다.

두번째 방법은 자리별로 가장 최댓값을 반복하여 찾는 것이다.

앞자리가 0이 아니면서 만들 수 있는 가장 최대의 자리수를 구하고 그만큼의 벡터를 초기화한다.

그리고 앞자리에 0이 아닌 가장 작은 숫자, 나머지에는 가장 작은 숫자들로 채운다.

최대의 자리수를 구했다면, 각 자리 수가 최대일 때 숫자가 가장 최대라는 것이 보장되므로 반복문으로 각 자리수를 최댓값으로 구한다.

여기서 m은 벡터를 초기화할때 채운 숫자들을 사고 남은 값으로 만들고, 남은 돈으로 다른 숫자로 교체할 수 있는경우

즉, 바꿀 숫자의 가격 - 현재 자리수의 가격 <= m이어야한다.

이 풀이 방법은 그리디하므로 가장 큰 숫자부터 찾아나가며 바꿀 수 있는 숫자를 발견하는 순간 종료 흐 m을 바꿔주고  다음 자리수로 넘어간다.

## 복잡도

첫번째 방법(dp)으로 풀 경우 o(L* m * n log L)의 시간이 걸리고, 각 칸에 벡터가 들어가고, 숫자가 복사되므로 공간복잡도 또한 o(L* m*n) 의 공간이 필요하다.

두번째 방법(그리디)으론 o(L*n )만큼의 시간이 걸리고 공간복잡도는 o(L+n)으로 훨씬 효율적으로 풀 수 있다.