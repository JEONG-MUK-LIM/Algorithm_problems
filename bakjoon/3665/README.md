# 문제:3665(최종 순위)

올해 ACM-ICPC 대전 인터넷 예선에는 총 n개의 팀이 참가했다. 팀은 1번부터 n번까지 번호가 매겨져 있다. 놀랍게도 올해 참가하는 팀은 작년에 참가했던 팀과 동일하다.

올해는 인터넷 예선 본부에서는 최종 순위를 발표하지 않기로 했다. 그 대신에 작년에 비해서 상대적인 순위가 바뀐 팀의 목록만 발표하려고 한다. (작년에는 순위를 발표했다) 예를 들어, 작년에 팀 13이 팀 6 보다 순위가 높았는데, 올해 팀 6이 팀 13보다 순위가 높다면, (6, 13)을 발표할 것이다.

창영이는 이 정보만을 가지고 올해 최종 순위를 만들어보려고 한다. 작년 순위와 상대적인 순위가 바뀐 모든 팀의 목록이 주어졌을 때, 올해 순위를 만드는 프로그램을 작성하시오. 하지만, 본부에서 발표한 정보를 가지고 확실한 올해 순위를 만들 수 없는 경우가 있을 수도 있고, 일관성이 없는 잘못된 정보일 수도 있다. 이 두 경우도 모두 찾아내야 한다.

## 입력

첫째 줄에는 테스트 케이스의 개수가 주어진다. 테스트 케이스는 100개를 넘지 않는다. 각 테스트 케이스는 다음과 같이 이루어져 있다.

팀의 수 n을 포함하고 있는 한 줄. (2 ≤ n ≤ 500)
n개의 정수 ti를 포함하고 있는 한 줄. (1 ≤ ti ≤ n) ti는 작년에 i등을 한 팀의 번호이다. 1등이 가장 성적이 높은 팀이다. 모든 ti는 서로 다르다.
상대적인 등수가 바뀐 쌍의 수 m (0 ≤ m ≤ 25000)
두 정수 ai와 bi를 포함하고 있는 m줄. (1 ≤ ai < bi ≤ n) 상대적인 등수가 바뀐 두 팀이 주어진다. 같은 쌍이 여러 번 발표되는 경우는 없다.

## 출력

각 테스트 케이스에 대해서 다음을 출력한다.

n개의 정수를 한 줄에 출력한다. 출력하는 숫자는 올해 순위이며, 1등팀부터 순서대로 출력한다. 만약, 확실한 순위를 찾을 수 없다면 "?"를 출력한다. 데이터에 일관성이 없어서 순위를 정할 수 없는 경우에는 "IMPOSSIBLE"을 출력한다.

## 해결방법

위상정렬을 이용하는 방법과 set을 사용하는 방법이 있다. (본질적으로는 같은 방법이다)

먼저 작년의 순위가 주어지는 정보를 이용해야한다.

예시로 5 4 3 2 1 로 주어졌다면

팀 5는 4,3,2,1 보다 높은 순위를 갖고 있는 것이다.

팀 4는 3,2,1

팀 3은 2,1

팀 2는 1

### set을 이용하는 경우

팀의 순서쌍의 개수가 모두 다르고 n-1,n-2,n-3,...,1,0개를 이룬다면 팀의 순위를 유일하게 구할 수 있는 것이다.

만약 같은 개수의 순서쌍을 갖는 경우가 생긴다면 IMPOSSIBLE을 출력해야한다.

참고로 '?' 가 출력되는 경우는 존재하지 않기 때문에 가능한 방법이다.

?가 왜 출력되지 않냐면 

순위변동이 주어지는 경우에 어떤 팀의 순서쌍이 1개 감소하면 또 다른 팀에서 1개 증가하기 때문이다. 

순위가 여러개가 가능한 경우는 존재하지 않는다. 모순이 생기는 순위만 존재할 뿐이다.

여기서 개수만을 이용하게 되면 m개의 순위 변동을 입력받는 도중에 순서쌍 개수가 같아지는 경우, 어떤 팀의 개수를 증가하고 감소해야하는지 정확히 판단하지 못하므로 

set을 이용하여 팀5의 set에 4,3,2,1을 추가, 팀4의 set에 3,2,1을 추가하는식으로 반복하여 각 팀이 어느 팀보다 우선순위에 있는지 set에 들어있는 원소로 판단 할 수 있다.

그 후에 순위변동이 일어나면 각 set에 있는 원소들을 삭제, 추가시켜주고 

각 set의 크기가 같은 값을 가지는 경우가 존재하는지 확인해주면 된다.

### 위상정렬을 사용하는 경우

반드시 그래프의 형태가 분기점없이 일자모양으로 이어져야 하므로 각 노드의 진입차수는 1씩 증가할 것이다.

마찬가지로 그래프를 인접행렬로 각 팀이 다른 팀보다 우선순위가 높다는 순서쌍 정보를 표현할 수 있다.

이때 m개의 순위변동 정보가 주어졌다고 해보자

예시로 a b 가 주어지면 a팀이 b팀보다 원래 높은 순위였다면,

a팀은 b팀보다 낮은 등수를 반드시 가져야 하므로 a의 진입차수가 1감소할 것이고, 반대로 b는 1증가할 것이다.

이를 m번 반복한다.

<br/>

이제 주어진 정보가 모순이 없는지 확인하기 위해 

위상정렬을 이용하기 위한 큐를 만들고 진입차수가 0인 모든 노드를 큐에 추가한다.

큐에는 무조건 n번의 enqueue와 dequeue가 되어야 한다.

큐의 맨 앞의 원소를 pop하면 그 원소와 이어지는 다음 원소(팀)의 진입차수를 1씩 감소시키고 순위를 기록한다.

그리고 진입차수가 0이 된 원소를 큐에 넣는다.

2개이상 들어가있다면 순위를 구분할 수 없는 경우가 생긴 것이라고 판단할 수 있다.

진입차수가 0인 것이 동시에 여러개 생긴 것이기 때문이다.

하지만 이 경우는 앞서 말했듯 실제로 존재할 수 없다.

그리고 n번 반복되기 전에 큐가 비어있게 되면 사이클이 생긴 것이다.

사이클이 생기면 진입차수의 연속성이 끊기기 때문이다.



## 복잡도

시간복잡도는 데이터 입력을 위한 o(n^2), (간선의 수인 m의 최댓값은 n^2에 근사)

데이터를 넣어둘 공간이 그만큼 필요하므로 공간복잡도도 o(n^2)가 된다