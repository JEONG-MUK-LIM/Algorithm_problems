#문제:12865(평범한 배낭)

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

##입력

첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

##출력

한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

##해결방법

이 문제는 물품이 분할할 수 있는 경우가 아니므로 0 - 1 knapsack 문제로 유명한 np문제이다.

물품을 넣는다. / 넣지 않는다. 두가지 선택지로 선택되므로 o(2^n), 완전탐색으로 해결하기엔 너무 오래 걸린다. 

정렬해서 푸는 것은 최적해가 보장되지 않는다. 

예시
```
k=7, 물품: (무게 2, 가치 10), (무게 3, 가치 9), (무게 4, 가치 12)

무게당 가치가 높은 순서대로 2(5.0), 3(3.0), 4(3.0)

2번 + 3번 = 무게5, 가치19

남은 용량2, 더 담을 수 없음

실제 최적해: 3번(무게3,가치9) + 4번(무게4,가치12) = 무게7, 가치21
```

이 문제를 풀기 위해서는 동적 프로그래밍을 활용해야 한다.

최대 무게가 k인 문제는 최대 무게가 k-w인 문제를 포함한다.

이때 무게가 w이면서 가치가 최대가 될 수 있는 경우를 선택한다.

sum[k] = sum[k-w] + v1 를 기억해놓고 다음의 sum[k-w] + v2과 비교해야한다.

즉 sum[k] = max(sum[k],sum[k-w] + v)

이를 모든 입력에 대해 반복한다.

물론 무게 w가 k를 초과해서는 안되므로 k >= w 인 경우에 대해서만 작동한다.

```
int* sum = new int[k+1]{0,};

for(int i = 0; i < n; i++){
    cin >> w >> v;
    if( k >= w ){
        sum[k] = max(sum[k],sum[k-w] + v)
    }
}
```

이 코드에서 sum 배열의 인덱스가 정답의 총 무게 합을 의미하는 게 아니라

문제의 조건인 들 수 있는 무게의 최댓값을 의미 한다.

즉 sum[k] 의 최댓값은 sum[k]의 최댓값, sum[k-1]의 최댓값, sum[k-2]의 최댓값, ... , sum[1]의 최댓값 중에 제일 큰 것이 선택 되어야 한다.


```
int* sum = new int[k+1]{0,};

for(int i = 0; i < n; i++){
    cin >> w >> v;
    for(int j = k; j >= 1; j--){
        if( j >= w ){
            sum[j] = max(sum[j],sum[j-w] + v)
        }
    }
}
```
이렇게 되면 정답의 총 무게 합이 k-1,k-2,..이 되더라도 sum[1]=0,sum[2]=0,...에서 시작된 값이 최종적으로 sum[k]를 만들면 sum[k]가 최댓값이 된다.

또한 물품은 한번만 배낭에 담길 수 있다.

j = 1부터 채우게 되면 여러번 반복해서 배낭에 들어가므로 역순으로 넣는다. 

(반복으로 담을 수 있는 건 0-1배낭문제가 아니라 완전배낭문제)

##복잡도

공간복잡도는 o(k), 시간복잡도는 O(nk)가 된다.

이 문제는 유명한 NP완전문제이다.

NP(Non deterministic Polynomial) 문제란 

다항시간에 비결정론적으로 해결가능한 문제의 집합이자, 다항 시간에 결정론적으로 검증 가능한 문제들의 집합이다. (어쨌든 해결 가능한 문제)

P문제는 다항시간에 결정론적으로 해결가능한 문제의 집합이다. 그렇다면 당연히 P는 NP에 속할 것이다.

NP 완전(complete)이란 
1. NP에 속한다. 정답 후보가 주어졌을 때, 그게 YES/NO에 해당하는 답임을 다항식 시간에 검증할 수 있는 문제를 의미

2. NP hard하다. NP의 모든 문제를 이 문제로 다항시간내로 바꿀 수 있는 경우를 의미한다.

그런데 시간복잡도는 o(nk)로 다항시간인 것 처럼 보이는데 어째서 NP에 속하게 될까?

<br/>

계산 복잡도 이론은 입력 크기가 커질수록 실행 시간이 어떻게 늘어나는가?에 초점을 둔다.

이 이론에서 다항시간이란 입력 크기(비트 수)에 대한 다항식 시간을 의미한다.

현실의 컴퓨터는 비트수가 한정되어 있기 때문에, 그 비트수에 영향을 가질 수 밖에 없다.

정렬 문제의 경우

정수 N개: a₁, a₂, ..., a_N (각 a_i는 최대 M)

입력 비트수: S = N × log₂M (각 원소 저장에 log₂M 비트 필요)

합병정렬의 경우 시간복잡도는 o(Nlog N)이다.

합병정렬은 입력이 끝나면 각 비트수가 얼마나 차지하든 비교 후 원소의 위치만 바꿔주는 연산만 하게 되므로 비트수에 연관이 없다.

(비교하는 데 비트 수는 사실 영향이 있지만, 기본 연산은 복잡도 이론에서 O(1)으로 둔다.)

계수정렬의 경우 시간복잡도는 O(N+M)이다. (여기서 M은 배열의 최댓값)

만약 M이 아주 커지게 된다면 S/N = log₂M , 2^(S/N) = M

O(N+2^(S/N)) 이므로 지수시간이 걸릴 수 있다.