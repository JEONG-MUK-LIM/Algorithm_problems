# 문제: 1114(통나무 자르기)

벌목꾼 백은진은 나무를 종이 공장에 옮겨야 한다. 하지만, 통나무의 길이가 너무 길어서 트럭에 들어가지 않으므로, 여러개의 조각으로 나누려고 한다.

통나무의 길이는 L이고, K개의 위치에서만 자를 수 있다. 통나무를 자를 수 있는 위치가 주어진다. 이 위치는 통나무의 가장 왼쪽에서부터 떨어진 거리이다. 통나무를 자를 수 있는 횟수는 최대 C번이다.

통나무의 가장 긴 조각을 작게 만들고, 그 길이를 구해보자.

## 입력

첫째 줄에 세 정수 L, K, C가 주어진다. 둘째 줄에는 통나무를 자를 수 있는 위치가 주어진다.

2 ≤ L ≤ 1,000,000,000

1 ≤ K, C ≤ 10,000

1 ≤ 자를 수 있는 위치 ≤ L

## 출력

첫째 줄에 두 개의 수를 출력한다. 첫 번째 수는 가장 긴 조각의 길이이고, 두 번째 수는 그 때 처음 자르는 위치를 출력한다. 만약 가능한 것이 여러 가지라면, 처음 자르는 위치가 작은 것을 출력한다.

## 해결방법

동적프로그래밍을 해보려고하면 dp의 배열의 크기가 C나 K만으로 끝나지 않는다.

그런데 k와 c는 1만이고 범위를 나타내기 위해 제곱하거나 둘이 곱하면 1억 이므로 시간제한에 걸릴 것이다.

마찬가지로 브루트포스로 조합을 하는 것도 시간초과이다 (10000 C 5000)

먼저 숫자의 범위가 매우 크므로 이분탐색의 가능성이 매우 높다.

이분탐색으로 막대의 가장 큰 값또는 가장 작은 값의 범위를 반씩 줄여나가면서 모든 막대를 해당 값 이하 또는 이상으로 나눠지도록 할 수 있는지 체크하는 건 k번으로 끝나고, 이를 log L 번 연산하므로 시간내에 풀 수 있을 것이다.

모든 막대를 가장 작은 값 이상으로 한다는 건 최소막대의 길이를 최대화 하는 것이다.

하지만 최소막대의 길이를 최대화 한다는 건 최대막대의 길이를 최소화하는 것과는 다른 문제이고 최대막대가 최소가 됨을 보장하지 않는다.
```
예시 : L = 10, k=3,, 각각 1,4,5, C = 2일 때 모든 막대의 최소길이는 1이 되므로 답이 1 4 를 선택해 자르는 것이 중복 답안으로 들어가게 된다.

그런데 이 경우 최대길이는 6이 되기 때문에 최대막대가 최소가 되지 않는다.
```

그러면 최대막대의 길이를 최소화 하기 위해서는 막대길이의 최댓값를 기준으로 자르되 모든 막대가 그 값보다 작은 길이를 갖게 되어야 한다.

또한 처음자르는 위치가 가장 작은 것을 선택해야 하므로 맨 앞에서부터 잘라서는 안된다.

왜냐하면 최대막대의 길이를 최소화 해야하기 때문에 최댓값보다 작다고 해서 무조건 자르는 게 아니라 그 다음 자르는 위치까지의 길이는 최댓값을 초과하지만 현재있는 위치에서 끝(or 이전에 잘린 부분)까지의 길이는 최댓값 이내라면 그 부분을 자르도록 선택해야 하기 때문이다.

이런 선택을 반복하면 오른쪽에 있는 막대가 가장 작게 될 가능성이 존재하므로 오른쪽에서부터 탐색하여 잘라내고, C보다 적은 횟수로 자를 수 있다면 자를 수 있는 위치중 가장 맨앞의 위치를 처음자르는 위치로 출력하고, C와 같은 횟수라면 탐색중 가장 마지막에 자른 위치를 맨앞의 위치로 출력한다

예시
```
L = 10, C=2
1 4 5

단1번의 자르기로 5이하의 막대로 나눌 수 있지만 C=2이기때문에 남는 횟수 1회를 가장 맨앞의 위치로 자르도록한다

L = 5, C= 3
1 2 3 4 5

가장 긴 막대의 길이는 2인데, 맨앞에서부터 자르면 자르는 위치가 2,4가 된다.

하지만 뒤에서부터 자르면 자르는 위치는 4,2가되며 남는횟수 1회를 맨앞의 위치로 자르면
2 1 이 출력된다.
```

## 복잡도

o(KlogL)
