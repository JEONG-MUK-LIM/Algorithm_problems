# 문제:13549(숨바꼭질3)

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

## 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

## 출력

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

## 해결방법

처음에는 수학적으로 풀 수 있을까 고민해봤는데 몇분간 고민해보고 직관적으로 아마 불가능할 것이라 판단했다. 

알아 낸 것으로는 K가 N보다 작은 경우에는 무조건 N-K를 해야한다는 것뿐이다.

고려해야 하는 상황이 너무 많아보였기 때문에 +1,-1을 해보고 거기서 *2를 해본다음 값을 비교하고 더 작거나 크거나하면 또 추가적인 행동을 하고.... 

이런식의 풀이방법은 탐색알고리즘을 사용하는 것과 거의 동일하다고 볼 수있다.

<br/>

이후 왜 다익스트라 알고리즘에 있는 문제인지 이해가 안됐는데, 

생각해보니 각 위치를 노드라고 하고 노드에 N-1, N+1, 2*N에 연결되어있다고 생각하고 가장 빠르게 원하는 위치를 찾을 수 있는 경로로 따라가면 다익스트라 알고리즘을 사용할 수 있을 것 같다.

그래도 이 문제는 경로의 가중치가 0 또는 1인 특이한 경우이기 때문에 굳이 다익스트라 알고리즘을 사용하지 않아도 된다. 

그래프 탐색 알고리즘에서 BFS는 가중치가 모두 같은 경우에 사용하는 것인데, 이를 이용하여 더 빠르고 쉽게 구할 수 있을 것이다.

특히 큐 대신 데큐를 이용하여 탐색하면서 다음 노드의 가중치가 0인 경우에는 데큐의 front에 추가, 가중치가 1인 경우에는 back에 추가해서 데큐가 비어있게 될때까지 데큐의 front를 꺼내는걸 반복하다보면 반복문이 동작하는 도중에 K를 만나게 된다.

이를 0-1 BFS라고 한다


## 복잡도

다익스트라 알고리즘은 o(E log V) 의 복잡도를 갖는데, 문제 조건상 E는 3*V에 근사한다.

0-1 BFS를 사용하면 o(E+V) 의 복잡도를 갖기 때문에 더 효율적으로 풀 수 있다.

또 공간복잡도도 더 효율적이게 사용할 수 있다. 그래프를 사용해서 간선으로 연결할 필요가 없기때문에 o(V)만 사용

(여기서 N=K, V는 노드개수이므로 N)