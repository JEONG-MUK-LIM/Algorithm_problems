# 문제: 1035(조각 움직이기)

최대 5개의 조각이 있는 5×5 크기의 보드가 있다. 김지민은 조각을 적절히 움직여서 모든 조각이 연결 요소를 이루게 하려고 한다. 즉 상하좌우로 인접한 조각을 모두 연결했을 때, 모든 쌍의 조각이 적어도 하나의 경로로 연결되어 있어야 한다.

한 번의 이동으로 하나의 조각을 상하좌우로 인접한 칸으로 옮길 수 있다. 보드의 상태가 주어질 때, 최소 몇 번 이동해야 모든 조각이 연결 요소를 이루게 되는지 구하는 프로그램을 작성하시오.

## 입력

첫째 줄부터 다섯째 줄까지 보드의 상태가 주어진다. 빈 곳은 '.'이고, 조각은 '*'이다. 조각은 1개 이상 5개 이하이다.

## 출력

첫째 줄에 문제의 정답을 출력한다.

## 해결방법

각 별들의 위치를 저장하는 벡터가 하나의 상태가 되고 

이 상태벡터를 큐에 넣고 해당 상태가 연결되어 있는지 확인한다.

상태벡터 대신 정수값으로 비트마스크를 사용하면 인덱싱해서 찾을 수 없고 특정 별의 위치에서 상하좌우 이동시 해당 별의 비트값의 위치변화를 찾기 까다로워진다. 그러니 각 원소가 별의 위치좌표를 나타낸 상태벡터를 사용하는 것이 타당하다.

이때 이미 방문한 적이 있는 상태인지 판단하는 것은 큐에 넣는 상태벡터대신 비트마스크를 사용해서 해시로 해당 값을 찾고, 없으면 방문한 적 없는 것으로 판단한다.

해시에 상태벡터를 전부다 추가하다보면 메모리가 많이 늘어나고 해싱해서 찾는 시간도 오래걸리기 때문이다.

어떤 하나의 상태가 연결되어있는지 확인하기위해 또 bfs를 사용하고,

연결 되어 있다는 건 상태벡터의 두 원소간의 맨해튼 거리가 1이라는 소리이므로 이를 이용해서 

맨해튼 거리가 1인 원소를 인접한 것으로 판단하고 큐에 넣는다.

<br/>

추가로 매번 bfs를 사용해서 주어진 상태벡터가 연결되었는지 판단할 필요는 없다.

처음부터 별들이 연결될 수 있는 모든 위치의 경우를 dfs로 탐색해서 찾고,

이를 비트마스크로 해시값으로 저장한 다음, bfs로 별들의 이동을 탐색하면서 처음으로 해시안에 존재하는 것을 발견했을 때 이동한 거리를 출력하도록 하면 시간복잡도를 훨씬 아낄 수 있다. 

## 복잡도

isConnected 함수 (n^2) 

상태공간 : o(25^n) 같은 상태가 중복해서 큐에 들어가진 않지만 순서를 고려해서 모든 별의 이동하는 경우를 체크해야 함

복잡도 o(25^n * n^2)


미리 connected 상태를 저장해놓을 경우 :

상태공간 : o(25^n)

큐에 넣기전 별끼리 겹치는지 확인 :o(n)

복잡도 o(25^n * n)