# 문제: 1103(게임)

형택이는 1부터 9까지의 숫자와, 구멍이 있는 직사각형 보드에서 재밌는 게임을 한다.

일단 보드의 가장 왼쪽 위에 동전을 하나 올려놓는다. 그다음에 다음과 같이 동전을 움직인다.

동전이 있는 곳에 쓰여 있는 숫자 X를 본다.

위, 아래, 왼쪽, 오른쪽 방향 중에 한가지를 고른다.

동전을 위에서 고른 방향으로 X만큼 움직인다. 이때, 중간에 있는 구멍은 무시한다.

만약 동전이 구멍에 빠지거나, 보드의 바깥으로 나간다면 게임은 종료된다. 형택이는 이 재밌는 게임을 되도록이면 오래 하고 싶다.

보드의 상태가 주어졌을 때, 형택이가 최대 몇 번 동전을 움직일 수 있는지 구하는 프로그램을 작성하시오.

## 입력

줄에 보드의 세로 크기 N과 가로 크기 M이 주어진다. 이 값은 모두 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 보드의 상태가 주어진다. 쓰여 있는 숫자는 1부터 9까지의 자연수 또는 H이다. 가장 왼쪽 위칸은 H가 아니다. H는 구멍이다.

## 출력

첫째 줄에 문제의 정답을 출력한다. 만약 형택이가 동전을 무한번 움직일 수 있다면 -1을 출력한다.

## 해결방법

메모이제이션과 해시셋을(2차원 부울벡터 visited도 사용가능) 활용한 dfs문제이다.

만약 메모이제이션을 사용하지 않는 경우 중복된 모든 경로들을 계속 탐색하므로 시간초과에 걸릴 수 있다.

bfs를 사용하는 경우 

큐에서 나오는 경우는 모두 다른 경로들에서 나오는 것이기 때문에, 큐에 2차원부울벡터를 집어넣어야한다.

그러면 너무 많은 것을 한번에 큐에 넣어야 하기 때문에(x,y좌표,지금까지 지나온 경로(즉, 2차원부울벡터),움직인 횟수) 함수로 구현 하기 쉬운 dfs를 사용했다.

이동하는 정도는 dx,dy에 matrix[x][y] 를 곱해서 구하면 되고, 메모이제이션은 해당 x,y좌표에 cnt가 더 작거나 같은 경우는 탐색할 이유가 없다. 왜냐하면 어짜피 그 뒤의 경로는 겹칠 것이고 이미 탐색한 것이기때문에 해당 좌표에서 최대로 움직일 수 있는 cnt값이 더 작거나 같게 나올 수 밖에 없다.

## 복잡도

1.시간복잡도의 경우

memo[x][y] 가 업데이트 되는 경우만 탐색을 진행한다.

즉 cnt값이 더 큰 경우에만 탐색하는데, cnt값은 n*m까지 늘어날 수 있으므로 

모든 칸은 최대 n*m 번 업데이트 될 수 있다.

이것을 모든 칸에 대해 반복하면 시간복잡도는 o((n*m) ^ 2)

2.공간복잡도의 경우 

모든 벡터나 해시셋은 n*m만큼 필요하고 재귀 콜스택은 최대 모든칸에 대해 늘어날 수 있으므로 o(n *m)