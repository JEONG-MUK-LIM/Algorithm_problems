# 문제: 11003(최솟값찾기)

N개의 수 A1, A2, ..., AN과 L이 주어진다.

Di = Ai-L+1 ~ Ai 중의 최솟값이라고 할 때, D에 저장된 수를 출력하는 프로그램을 작성하시오. 이때, i ≤ 0 인 Ai는 무시하고 D를 구해야 한다.

## 입력

첫째 줄에 N과 L이 주어진다. (1 ≤ L ≤ N ≤ 5,000,000)

둘째 줄에는 N개의 수 Ai가 주어진다. (-109 ≤ Ai ≤ 109)

## 출력

첫째 줄에 Di를 공백으로 구분하여 순서대로 출력한다.

## 해결방법

첫번째로 세그먼트 트리를 이용했으나 시간초과에 걸렸다.

계산해보면 최악의 경우 nlogL (n번 L의 범위에서 최솟값을 찾음)인데 n,L은 최대 5 * 10^6이므로

log (5백만) = 약 log 4 * log 2^20(2^10 = 1024, 즉 1000정도) 이므로 22 * 5백만 = 1억1천이 된다.

거기에 build연산이나 추가 사이클까지 더하면 시간초과가 나올 수 있는 연산 수 이다.

그러므로 다른 방법을 이용해야 한다.

<br/>

입력은 하나씩 받으면서, A_i는 D_i의 범위에 무조건 포함된다.

범위 L은 한칸씩 이동하므로 하나의 원소를 빼고, 하나의 원소를 더하는 연산이 일어날 것이다.

문제는 하나의 원소를 뺄 때, 그 원소가 최솟값이라면 나머지 범위에서 그다음 최솟값을 o(1)에 찾을 수 있어야 한다.

그렇게 하기 위해서는 2번째로 작은 값을 저장해야 했는데 min값과 secondMin값을 저장하면

빠지는 원소에서 min값대신 secondMin값이 빠지는 경우, 두번째로 작은 값을 체크할 수 없게 된다.

여기서 중요한건 L범위 내의 두번째 최솟값을 알고있으면 나머지값은 필요가 없게되므로 

매번 입력이 들어오면 자료구조에 추가하되 자료구조 안에 가장 최솟값을 두고, 해당 최솟값이 범위를 빠져나왔다면 앞에서 빼준다.

그리고 그 입력의 크기와 비교하여 그 입력보다 큰 값이 자료구조내에 있다면 최솟값이 빠져나온 방향과 다른 방향에서 값을 빼주어야 한다.

즉 양방향의 자료구조인 데큐가 필요하다.


## 복잡도

n개의 입력을 받고 각 입력을 받으면 데큐에 넣고, 빼고(뺸다는 건 들어올 수 있는 만큼만 연산이 된다는 걸 의미한다.), D_i를 출력하므로 o(n)