# 문제: 3015(오아시스 재결합)

오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.

이 역사적인 순간을 맞이하기 위해 줄에서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해졌다.

두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.

줄에 서 있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)

둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 231 나노미터 보다 작다.

사람들이 서 있는 순서대로 입력이 주어진다.

## 출력

서로 볼 수 있는 쌍의 수를 출력한다.

## 해결방법

출력 값이 서로 볼 수 있는 쌍의 수이기 때문에 500000_C_2 이므로

500000 * 499999 / 2 가 되니 int 의 범위를 벗어남에 유의한다.

또 조건을 잘 파악해야 한다.

A또는 B보다 큰 사람이 없는 경우라는 건 

A,B사이에 가장 큰 값이 D라고 할 때,

(A < D or B < D)^C  즉 A >= D && B >= D라는 뜻이다.

<br/>
스택을 활용해서 푸는 문제이다.

값의 범위가 50만이기때문에 n^2의 시간이 걸려선 안된다.

dp를 사용하려면 점화식을 만들어야 하는데, 점화식을 세우는 것이 매우 복잡해 보였다.

세그먼트 트리를 사용해 구간의 최댓값을 구해도 최악의 경우 (계단형으로 감소) n^2이 되므로 더 최적화된 자료구조를 사용해야 한다고 판단했다.

<br/>

1개의 수만 주어진 상태라면 쌍을 만들 수 없으므로 경우의 수를 세지 않는다.

2개이상의 수가 주어진 상태라면 바로 앞의 있는 사람과 서로 마주보는 경우를 반드시 세야한다(answer +=1)


A,B사이에 가장 큰 값 D가 B보다 크다면 D이전의 값과 B의 쌍을 만들 수 없다.
어짜피 D가 가로막고 있기 때문이다.

한번에 값을 쌓아두고 차례대로 확인하는 게 아니라, i번째 값이 하나 들어오면 i-1번째 값과 쌍을 만들 수 있는지 확인한다. (이 경우는 바로 앞의 사람과 서로 마주 보는 경우이므로 반드시 +1)

i와 i-2번째 값이 쌍을 만들 수 있는지 확인한다. i-1이 i보다 큰지 확인한다. 여기서 i-2번째 값이 i-1보다 크거나 같고, i보다 크거나 같다는 것이 보장 되어야만 한다. 

i-1번째 값이 i보다 크다면 i-2와 i는 쌍을 만들 수 없지만, i라는 값을 기록해둬야 뒤에 들어 오는 입력과 비교하여 i-1번째와 쌍을 만들 수 있는지 확인할 수 있다.

i-1번째 값이 i보다 작거나 같다면 i-2와 i는 쌍을 만들 수 있다.

같다면 뒤에 오는 값이 i-1,i와 각각 쌍을 만들 수 있으니 i-1을 내버려 둔다.

하지만 i-1가 i보다 작다면 그 뒤에 들어오는 값은 i-1과 쌍을 만들 수 없게 된다.

그러므로 이 값은 필요 없어 졌으니 뺀다. 

그후 i-3과 i가 쌍을 만들 수 있는지 확인하기 위해 i-2와 i값을 비교한다.

<br/>
값을 기록해야하고, 가장 마지막의 값과 비교해야하고, pop하고나서 또 마지막의 값과 비교하는 식이므로 LIFO의 자료구조인 스택이 필요하다는 것을 알아 낼 수 있다.

<br/>
자세한 방법은 다음과 같다.

i번째 값을 스택의 top과 비교한다.

1.더 크다면 스택이 비거나 top이 i번째 값보다 더 큰 값을 가질 때 까지 스택에 있는 값을 pop 하면서 경우의 수를 센다.

2.더 작다면 바로 앞의 있는 사람과 서로 마주보는 경우만 가능하다.

더 앞에 있는 사람은 볼 수 없으니 넘어가고, 현재 보다 더 작은 사람이 뒤에 나올 수도 있으므로 스택에 값을 push해놓는다.

3. 서로 같다면 같은 값을 갖는 스택내의 원소 수만큼 쌍을 만들 수 있다.
```
<-bottom    ->top  입력
예시: ... 4 4 4      4 -> 1+2+3 = 6개의 쌍
```

그런데 뒤에 또 같은 값이 들어올 수 있으므로 pop해서는 안되고, 지금까지의 연속된 횟수를 기록해야한다.
```
<-bottom    ->top  입력
예시: ... 4 4 4 4    4 -> 1+2+3+4 = 10개의 쌍
```

그러므로 스택내에 들어가는 값이 연속되는 경우 그 연속되는 횟수가 몇번인지 기록을 해두기 위한 변수도 같이 들어가야 한다.

즉 stack<int> 대신 stack<pair<int,int>>를 사용한다.

또한 1번에서 pop하고 경우의 수를 셀 때 , 연속되는 횟수만큼 쌍의 수에 더한다.
```
<-bottom       ->top  입력
예시: 5   4   4   4    5  -> 5 5, answer += 3, 

```
반복문 마지막마다 answer+=1하므로 (바로 직전의 값과 쌍을 만드는 경우) 

answer에는 총 4만큼 더함


3번에서 4가 한번 더 들어올 때, answer += 4가 되므로 pop해서 answer에 연속되는 수만큼 더하고, 다시 스택에 연속되는 횟수를 1만큼 증가시켜 스택에 push한다

## 복잡도

모든 원소는 최대 1번 push되고, 1번 pop될 수 있으므로 o(N)