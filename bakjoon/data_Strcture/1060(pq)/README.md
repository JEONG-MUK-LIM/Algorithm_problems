# 문제: 1060(좋은 수)

정수 집합 S가 주어졌을때, 다음 조건을 만족하는 구간 [A, B]를 좋은 구간이라고 한다.

A와 B는 양의 정수이고, A < B를 만족한다.
A ≤ x ≤ B를 만족하는 모든 정수 x가 집합 S에 속하지 않는다.
정수 x를 포함하는 좋은 구간의 개수가 정수 y를 포함하는 좋은 구간의 개수보다 작으면 x는 y보다 더 좋다고 한다. x와 y를 포함하는 좋은 구간의 개수가 같거나, 구간의 개수가 둘 다 무한대와 같은 경우, 작은 수를 더 좋다고 한다.

집합 S가 주어지고, 이를 이용해 전체 정수를 더 좋은 수가 앞으로 오게 정렬했다고 가정하자. 앞에 오는 수 n개를 구해보자.

## 입력

첫째 줄에 집합 S의 크기 L이 주어진다. 둘째 줄에는 집합에 포함된 정수가 주어진다. 셋째 줄에는 n이 주어진다.

1 ≤ L ≤ 50
집합 S에는 중복되는 정수가 없다.
집합 S에 포함된 모든 정수는 1보다 크거나 같고, 1,000,000,000보다 작거나 같다.
1 ≤ n ≤ 100

## 출력

상위 N개의 수를 공백으로 구분해 출력한다.

## 해결방법

정수 x를 포함하는 좋은 구간의 수를 찾아야한다.

이때 x를 포함하는 구간을 제한하는 기준은 S의 원소가 된다.
```

S의 원소를 입력받고 정렬한 원소가 오름차순으로 a0, a1, a2,... an 일때

x의 위치가 다음과 같으면

a0      a1   x    a2      a3        

x를 포함하는 구간은 [a1+1,a2-1] 에 한정된다. 좋은 구간내에는 s의 원소는 들어갈 수 없기때문이다.
```
원소 x를 포함하기 위해서는 3가지 조건중 하나에 부합해야한다.

1.구간이 a1+1, a1+2,.... x-1부터 x까지

a1+1부터 x까지의 원소의 개수 , 즉 x-(a1+1)

2. 구간이 x부터 x+1,x+2,....,a2-1까지 , [x,x+1], [x,x+2], ... [x,a2-1]

a2-1 부터 x+1까지의 원소의 개수, 즉 a2-1 - x

3. 구간이 a1+1부터 x-1에서 시작하면서 , x+1부터 a2-1에서 끝남

즉 [a1+1,x+1], [a1+1,x+2],... [a1+1,a2-1], [a1+2,x+1],[a1+2,x+2],...[a1+2,a2-1],...

그러므로 (x-(a1+1)) * (a2-1 -x)개

간단하게 예시를 들면
```
s = 1,7

구간내 정수는 2,3,4,5,6

원소 4를 포함하는 좋은구간의 개수는 총 (6-4) + (4-2) + (4-2)*(6-4) 가 된다.

```

문제는 모든 정수에 대한 좋은 구간의 수를 저장할 수 없다. 최대 10억까지의 수를 가질 수 있으니

10억번의 연산을 할 수는 없기 때문이다.

필요한건 n <= 100 이라는 사실을 이용해서 가장 작은 구간의 개수를 갖는 100개의 정수를 찾는 것이다.

이 문제의 가장 큰 함정은 좋은 구간의 개수가 0인 정수도 포함해야한다는 것이다.

그러므로 S내에 들어있는 원소들은 좋은구간의 개수가 0개이니, 이 또한 우선순위 큐에 들어갈 대상이 된다.

또한 S = {2,3} 이고, n = 3이라면 출력은 1,2,3이어야한다. 즉 0부터 S내 가장 작은 원소도 구간으로 포함해야하고, 나뉘어진 구간내 정수가 하나인 경우도 우선순위 큐에 넣어주어야 한다.

for문을 돌면서 s로 인해 나뉘어지는 구간들에서의 인덱스를 저장해주고,(0이면 양끝, 1이면 양끝에서 +1, -1한 정수, 1,2,3,4,5에서 인덱스가 2라면 5-2 = 3, 1+2=3이니 같은 경우는 중복해서 pq에 들어가지 않도록 스킵)

그 인덱스를 이용하면 나뉘어진 구간 내에서의 정수를 포함하는 좋은구간의 개수를 한번에 구할 수 있다. 구한 구간을 pq에 넣고 가장 작은 n개를 뽑는다.

집합 S로 나뉘어지는 구간 내의 정수의 수가 n개가 되지 않으면 구간의 개수가 무한한 (S의 가장큰 원소보다 큰 정수) 정수를 가장 작은 순부터 출력하도록한다.

이때 일반식을 통해 구한 좋은 구간의 개수는 int의 범위를 벗어날 수 있다. 하지만 최대 5000개의 원소를 탐색하므로 long long 범위를 벗어나지는 않는다.


## 복잡도

최대 L*n 만큼의 탐색을 하고 그만큼 우선순위 큐에 들어가게 되므로 o( nL * log nL)