# 문제: 6549(히스토그램에서 가장 큰 직사각형)

히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 
히스토그램에서 가장 넓이가 큰 직사각형을 구하는 프로그램을 작성하시오.

## 입력

입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h1, ..., hn (0 ≤ hi ≤ 1,000,000,000)가 주어진다. 이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 모든 직사각형의 너비는 1이고, 입력의 마지막 줄에는 0이 하나 주어진다.

## 출력

각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.

## 해결방법

이 문제는 스택을 이용하는 방법이 있고, 재귀(분할정복)를 이용하는 방법이 있다.

재귀를 이용하는 방법은 recursive에 추가한다.

여기선 스택을 이용하는 방법을 설명한다.

<br/>

인덱스가 증가되면서 막대들이 계단식으로 증가하는 모습을 상상해보자.

각각의 막대들이 넓이의 왼쪽 끝의 시작점으로 할 때 각각의 넓이를 구하는데 지장이 생기지 않는다. 

현재 인덱스를 기준으로 각 막대의 인덱스를 기억하면

현재 인덱스 - 각 막대의 인덱스 = 너비가 된다.

그러면 인덱스를 알고 있으니 높이를 저장한 배열에서 꺼내와서 곱하면 넓이를 구할 수 있다.

여기서 인덱스를 늘리더라도 계단식으로 증가하는 형태가 유지 된다면 넓이를 구하는 데 문제가 생기지 않는다.

이때 어디까지 계단식 모양이 유지될 지 모르므로 각 막대를 기준으로 하는 넓이를 구할 때의 너비를 완전히 파악했다고 할 수 없다.

그런데 현재 막대가 바로 직전의 막대보다 작아지는 경우,

그 순간 이전의 막대들의 너비가 결정되는 것이고, 그중 최댓값을 구할 필요가 있다.

이때 현재 막대에서 왼쪽방향으로 탐색시 더 낮은 막대들은 아직 너비가 구해진 것이 아니므로

처음으로 높이가 더 낮은 막대와 현재 막대 사이에 있는 막대들의 중에서 가장 큰 넓이를 갖는 것을 max값으로 기억해두고, 다시 데이터들을 계단형으로 쌓아가기 시작하는 식으로 반복한다.

인덱스가 n까지 다다르면 너비가 정해지게 되므로 기억하고 있는 인덱스들의 넓이들을 모두 계산하면 된다.

생각해보면 이를 위해서는 스택이 필요하다는 것을 깨달을 수 있다.
 
## 복잡도

n번의 탐색만을 하므로 시공간 복잡도 모두 o(n)

스택을 사용하는 것이 분할정복을 사용하는 것보다 더 효율적이다.