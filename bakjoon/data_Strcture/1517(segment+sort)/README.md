# 문제: 1517(버블 소트)

N개의 수로 이루어진 수열 A[1], A[2], …, A[N]이 있다. 이 수열에 대해서 버블 소트를 수행할 때, Swap이 총 몇 번 발생하는지 알아내는 프로그램을 작성하시오.

버블 소트는 서로 인접해 있는 두 수를 바꿔가며 정렬하는 방법이다. 예를 들어 수열이 3 2 1 이었다고 하자. 이 경우에는 인접해 있는 3, 2가 바뀌어야 하므로 2 3 1 이 된다. 다음으로는 3, 1이 바뀌어야 하므로 2 1 3 이 된다. 다음에는 2, 1이 바뀌어야 하므로 1 2 3 이 된다. 그러면 더 이상 바꿔야 할 경우가 없으므로 정렬이 완료된다.

## 입력

첫째 줄에 N(1 ≤ N ≤ 500,000)이 주어진다. 다음 줄에는 N개의 정수로 A[1], A[2], …, A[N]이 주어진다. 각각의 A[i]는 0 ≤ |A[i]| ≤ 1,000,000,000의 범위에 들어있다.

## 출력

첫째 줄에 Swap 횟수를 출력한다

## 해결방법

수의 범위를 보았을 때 실제로 버블소트를 구현하는 문제는 아니다.

버블정렬로 값을 정렬하는 횟수는 오른쪽의 값과 비교하면서 서로의 위치를 바꾸어 주는 횟수이다.

정렬후 나올 수 있는 원소의 순서는 정해져 있다. 그러므로 역순쌍(i<j 이면서 arr[i] > arr[j]인 쌍 (i,j))의 개수는 정해져 있다. 쌍의 개수이므로 역순쌍의 개수는 최대 n^2이 될것이다.

모든 원소는 원래의 위치에서 정렬후의 위치로 이동을 하게 된다.

여기서 값의 비교 후 두 원소가 한칸씩 이동하게 되며, 하나의 역순쌍을 제거하게 된다.

그러므로 역순쌍이 모두 사라지게하는 데 걸리는 시간이 n^2이 되고 이는 버블정렬의 시간복잡도가 된다.

swap의 횟수는 역순쌍의 횟수이고 n의 범위가 50만이므로 최대 25 * 1e10 만큼 역순쌍을 갖게 되니까 결과값을 반드시 long long 타입으로 해주어야 한다.

<br/>
정렬되지 않은 모든 값이 주어졌을 때, 버블 정렬을 하는 것과 삽입정렬로 하나의 값의 위치를 찾아내는 것을 반복하는 총 횟수는 동일함을 알 수 있다. 

삽입정렬 또한 하나의 비교를 통해 하나의 역순쌍을 제거하는 것이기 때문이다.

그러므로 삽입정렬을 하는 것처럼, 하나의 입력을 받았을 때 그 값의 위치를 알아내면 이동해야하는 횟수를 알 수 있고, 이를 계속해서 결과에 더해주면 될 것이다.

<br/>

여기서 문제는 매번 입력을 받을 때마다 그 값의 위치가 이전까지 주어진 값들을 정렬한 배열의 기준으로 찾아야 한다는 것이다.

예를 들어 5 4 2 2 1 순으로 입력을 받을 때,  5 4 2 까지 입력을 받았고, 다음에 2라는 숫자의 인덱스를 찾아야 한다.

그러면 2가 들어갈 위치는 5 4 2 를 정렬한 2 4 5 를 기준으로 찾아야 한다는 것이다. 

문제는 값의 위치를 찾기위해 매번 정렬을 해주면 삽입정렬의 시간만큼 n^2의 시간이 걸리게 된다.

그런데 생각해보면 굳이 정렬을 할 필요는 없다. 이제까지의 배열은 이미 정렬이 되었다고 가정하므로 뒤에 있는 숫자일 수록 큰 값일 것이고 큰 값의 개수만큼 이동을 한다.

즉 이전까지 입력받은 배열에서 현재 입력값보다 더 큰 값의 개수만큼 이동을 하도록 정해져 있기 때문에 현재 입력값보다 더 큰 값의 개수를 n보다 적은 시간으로 알아내야한다.

이를 위해 세그먼트 트리와 좌표압축을 이용한다.

<br/>

세그먼트 트리의 리프노드를 값의 범위만큼 만들고, 구간에 포함되는 값들의 개수의 누적합을 저장한다.

그런데 값의 범위가 +- 10억까지 되므로 이를 실제로 만들 수는 없다.

이때 값 자체는 50만번만 입력받으므로 좌표 압축을 이용한다.

좌표압축은 실제로 주어진 값이 있으면 그 값의 크기순서로 바꾸어서 배열을 사용하는 것이다.

예를 들어 5 3 2 1e9 2 라고 하면  2 1 0 3 0 으로 바꾸어서 사용한다.

값 그자체보단 대소 비교나 순서같은게 필요할 때 사용하는 방식이다.

값의 입력을 받을 때 pair형으로 받아서 arr[i] = (실제값,인덱스) 순으로 저장한다.

그후 정렬한다음 새로운 배열을 선언해서 newArr[arr[i].second] = ++rank 로 저장하되

값이 중복되는 경우는 이전의 rank값을 그대로 이용한다.

newArr의 순서대로 값을 입력받을 때마다 세그먼트 트리의 노드의 값(해당 rank의 개수) 업데이트해주면 된다. 

처음에는 모두 0개일 것이므로 build함수는 필요 없다.

## 복잡도

공간복잡도 o(n)

시간복잡도 정렬 o(log n), 세그먼트트리 쿼리를 n번 반복하니 o(nlog n)