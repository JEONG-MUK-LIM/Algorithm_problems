# 문제: 2042(구간 합 구하기)

어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.

## 입력

첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b(1 ≤ b ≤ N)번째 수를 c로 바꾸고 a가 2인 경우에는 b(1 ≤ b ≤ N)번째 수부터 c(b ≤ c ≤ N)번째 수까지의 합을 구하여 출력하면 된다.

입력으로 주어지는 모든 수는 -2^63보다 크거나 같고, 2^63-1보다 작거나 같은 정수이다.

## 출력

첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -2^63보다 크거나 같고, 2^63-1보다 작거나 같은 정수이다.

## 해결방법

세그먼트 트리를 이용해서 구간합을 구한다.

세그먼트 트리를 만들기 위해서는 build , find, update(필요시)함수가 필요하다.

구간합을 찾는 세그먼트 트리와 최솟값을 찾는 세그먼트 트리는 구현 방법이 살짝 다르다.

<br/>
build함수에서는 build만 재귀적으로 호출한다. 

파라미터는 node(세그먼트트리의 노드번호), start,end(해당 노드번호가 담당하는 구역)

이때 리턴 값은 

(start와end가 같을 때) segment[node] = arr[node]

(그외) segment[node] = left + right 

left = build(node * 2,start, mid) , right= build(node * 2 + 1,mid+1,end)이다

<br/>

find 함수에서 최솟값을 구하는 경우와 구간합을 구하는 경우, 범위를 잘 구분해야한다.

파라미터는 node(세그먼트트리의 노드번호), start,end(해당 노드번호가 담당하는 구역)

l,r(내가 찾고 싶은 영역)

(l < start , r > end) 

노드번호가 담당하는 영역과 완전히 l,r이 일치하지 않으면 0을 리턴한다.

(l <= start, end <= r)

해당 노드번호가 담당하는 영역에서 l,r이 완전히 겹치는 상황이면(l,r이 더 넓음)

segment[node]를 리턴,

일부만 겹치는 경우 start,end가 l,r과 아예 겹치지 않거나 완전히 겹칠 때 까지 left,right를 나눠 그 합을 구한다.

<br/>
update의 경우 파라미터는 node,start, end, idx, val

하나의 노드의 값이 변할 때 그 부모노드들을 모두 업데이트 해줘야한다.

값을 바꾸려는 원소의 인덱스 값이 해당 노드의 영역에 포함되어 있지 않으면 함수를 리턴

start와 end가 같다면 해당 노드의 값을 바꿔주고, 그외 start와 end사이 idx가 어딘가에 있는 상황이라면 update(왼쪽), update(오른쪽)해주고 segment[node] = segment[2*node] + segment[2*node + 1]로 값을 수정한다.

## 복잡도

build: 등비수열 공식 n*(1-(1/2) ^ 2)/ (1-(1/2)^2) = 2n

최대 2n개의 노드를 생성하므로 o(n)

find: 트리를 내려가면서 일치하는 구간을 찾음

양끝에 쿼리구간과 부분만 겹치는게 반복되어서 리프노드까지 가는 경우 

2 *log n ~ 4 *log n -> o(log n)

update:

트리의 리프노드의 영역과 idx가 일치할 때 까지 내려감 -> log n

이후 해당 노드의 조상노드들을 모두 수정 -> log n

즉 o(log n)

공간복잡도: 세그먼트 트리를 생성하기 위해 4*N 크기의 배열생성 -> o(n) 

