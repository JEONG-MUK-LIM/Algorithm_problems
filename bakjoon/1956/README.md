# 문제: 1956(운동)

V개의 마을와 E개의 도로로 구성되어 있는 도시가 있다. 도로는 마을과 마을 사이에 놓여 있으며, 일방 통행 도로이다. 마을에는 편의상 1번부터 V번까지 번호가 매겨져 있다고 하자.

당신은 도로를 따라 운동을 하기 위한 경로를 찾으려고 한다. 운동을 한 후에는 다시 시작점으로 돌아오는 것이 좋기 때문에, 우리는 사이클을 찾기를 원한다. 단, 당신은 운동을 매우 귀찮아하므로, 사이클을 이루는 도로의 길이의 합이 최소가 되도록 찾으려고 한다.

도로의 정보가 주어졌을 때, 도로의 길이의 합이 가장 작은 사이클을 찾는 프로그램을 작성하시오. 두 마을을 왕복하는 경우도 사이클에 포함됨에 주의한다.

## 입력

첫째 줄에 V와 E가 빈칸을 사이에 두고 주어진다. (2 ≤ V ≤ 400, 0 ≤ E ≤ V(V-1)) 다음 E개의 줄에는 각각 세 개의 정수 a, b, c가 주어진다. a번 마을에서 b번 마을로 가는 거리가 c인 도로가 있다는 의미이다. (a → b임에 주의) 거리는 10,000 이하의 자연수이다. (a, b) 쌍이 같은 도로가 여러 번 주어지지 않는다.

## 출력

첫째 줄에 최소 사이클의 도로 길이의 합을 출력한다. 운동 경로를 찾는 것이 불가능한 경우에는 -1을 출력한다.

## 해결방법

다익스트라 알고리즘에서 시작점의 거리를 0으로 초기화하지 않으면 해당 점으로 돌아오는 사이클이 존재하는 경우 다익스트라의 반환벡터의 시작점의 값이 사이클의 총 거리의 합이 될 것이다.

문제는 이걸 모든 점에 대해 반복하는 건 비효율적이다. 

사이클의 최단경로는 사이클 내에서 시작점이 어디든 간에, 그 경로 값이 같고 지나는 경로가 같기 때문에 모든 v에 대해 최단 거리를 구하는 건 중복작업이 되기 때문이다.

즉 이 문제는 all pairs shortest path문제이고 이는 플로이드 워셜 알고리즘을 사용해야 한다.

플로이드 워셜 알고리즘은 한번 구할 때 모든 점이 각각 시작점일 때, 다른 점으로의 최단 경로를 한번에 구하는 알고리즘이다. 

플로이드 워셜 알고리즘의 순서는 다음과 같다.

1.  정점의 수가 v라면 v^2 (인덱스의 편의를 위해 (v+1)^2) 만큼의 인접행렬을  조건에서 거리의 최댓값으로 초기화, (i,j)는 현재 구한 정점 i에서 j로의 최단거리

2.  (i,i)를 따라 좌상우하 대각선으로 각 원소를 0으로 초기화(자기 자신으로의 최단거리는 0이므로)

3. 그래프 입력을 받고 a에서 b로 가는 가중치가 c라면 (a,b) = c로 초기화

4. 점 k를 경유해서 i에서 j로 가는 거리인 i->k , k->j의 합이 기존보다 작으면 업데이트

5. 모든 k(<=v) 에 대해 모든 i,j를 반복 

이렇게 행렬을 구하고 사이클의 거리를 구해야 하므로 i->j, j->i 거리의 합이 가장 작은 경우를 반복문으로 찾아주면 된다.

이때 i == j가 같은 경우는 제외하고 구한다.
    

## 복잡도

플로이드 워셜 알고리즘의 시간복잡도는 o(v^3) 이다.

다익스트라 알고리즘의 시간복잡도는 o(E log v)인데 만약 모든 v에 대해 반복한다면

o(E * v log v)가 된다. 그래프가 조밀(dense) 한 경우 E는 최대 v(v-1)의 값을 가지므로 

o(v^3 log v) 가 되므로 플로이드 워셜 알고리즘에 비해 비효율적일 수 있다.

공간복잡도는 o(v^2)