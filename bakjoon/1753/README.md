# 문제:1753(최단경로)

방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.

## 입력

첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1 ≤ K ≤ V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.

## 출력

첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.

## 해결방법

다익스트라 알고리즘을 사용하는 문제이다.

다익스트라 알고리즘은 single source shortest path 문제를 푸는 알고리즘으로,

시작점이 주어지면 모든 다른 점까지의 최소거리를 구하는 문제이다.

프림알고리즘과 유사하며 다른점은 우선순위 큐에 가중치를 넣을 때, 이전에 지나온 노드들의 거리 값을 현재의 간선의 가중치와 더해서 fringe Set에 넣는다는 차이가 있다.

(프림알고리즘은 더하지 않고 그냥 간선의 가중치만 넣는다.)

우선순위 큐인 fringe Set, 시작점으로부터의 다른 모든점의 거리를 적은 벡터인 tree Set이 있다.

노드의 수는 최대 20000, 가중치는 10이므로 최대 20만의 거리를 갖는다.

이를 tree Set을 초기화 할때 활용한다.

다익스트라 알고리즘은 다음 과정을 거친다.

0. 시작점을 fringe Set에 추가한다.

1. fringe Set에서 가장 작은 경로 값을 갖는 노드를 꺼낸다.

2. 현재노드가 tree Set에 있는 값보다 작은 경로 값을 갖지 않는 경우 continue

3. 갖는 경우에는 tree Set에서 (현재 노드의 경로 값 + 다음 노드로의 간선의 가중치)보다 큰 경로 값을 갖고 있는 모든 인접한 다음 노드를 우선순위 큐에 추가하면서 
treeSet의 값을 업데이트 한다.

모든 점의 경로 값을 구할 때까지 1~3을 반복한다.

## 복잡도

우선순위 큐를 사용했고 큐에 노드가 최대 간선 수(E)만큼 들어 갈 수 있다.

그리고 그것을 모든 간선에 대해 반복하므로 o(Elog E)이다. 그리고 E = V^2에 근사하니 log E를 log V
로 쓸 수도 있다

(일단 큐에 넣고 나중에 최단거리인지 아닌지 판단하므로 lazy evaluation 이라 할 수 있다.)

lazy evaluation을 하지 않는 방법도 있다.

이때는 우선순위 큐 대신에 set(레드블랙트리)을 사용한다.

set에 모든 노드를 넣고 해당 경로까지의 가중치 총합만 수정해준다.

set.begin()은 항상 가장 작은 값을 가리키기에 우선순위 큐처럼 사용 가능하고

중복된 노드를 추가하지 않아도 되므로 log V만큼만 사용하게 된다.(가중치 값을 수정하고 싶으면 삭제후 삽입)

후보 중복없이 큐의 노드 키 값을 직접 바꾸므로 이 경우는 eager evaluation이다.

아주 최악의 상황이 아니라면 그냥 우선순위 큐를 쓰는 게 더 효율적일 수 있다.

set을 쓰는 코드는 다음과 같다.

```
#include <set>
#include <vector>
using namespace std;

vector<int> dijkstra(int start, int V, const vector<vector<pair<int, int>>>& graph) {
    vector<int> dist(V+1, 1e9);
    set<pair<int, int>> s; // (거리, 정점)
    dist[start] = 0;
    s.insert({0, start});

    while (!s.empty()) {
        auto [curDist, u] = *s.begin();
        s.erase(s.begin());

        for (auto [v, w] : graph[u]) {
            if (dist[v] > curDist + w) {
                if (dist[v] != 1e9) {
                    s.erase({dist[v], v}); // 기존 값 제거 (Decrease Key)
                }
                dist[v] = curDist + w;
                s.insert({dist[v], v});
            }
        }
    }
    return dist;
}
```

공간복잡도는 o(E+V)
