#문제:

그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.

##입력

첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.

##출력

첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.

##해결방법

그래프의 탐색방법 두가지인 DFS와 BFS를 구현하는 방법이다.

공통점으로는 visited 벡터가 필요하다는 것이다.

그래프의 노드번호가 자동으로 1,2,3,.. 으로 되는 가중치가 없는 무향그래프는 

vector<vector<int>>를 이용하면 간단하다.

그외의 경우는 구조체를 정의해주어야 한다.

먼저 DFS는 함수를 이용하고 함수에 들어오면 현재 노드번호에 해당하는 visited의 상태를 바꿔주면서, 그 주변의 방문하지 않은 연결된 인접노드들에 대한 dfs를 재귀형태로 구현해주면 된다.
<br/>
그다음 BFS는 큐가 필요하다. 큐에 시작 노드를 추가하고 큐가 비어있지 않은 동안 현재 노드번호(큐의 front)를 확인해주면서 방문한 적이 없고 인접한 연결된 노드를 큐에 push를 한다. push를 하면서 상태를 바꿔줘야 중복된 노드가 들어가지 않고 효율적으로 연산할 수 있게 된다.

여담으로 2차원 배열을 쓰기위해 vector<vector<int>>나 int** 는 사실 메모리차원에서 별로 효율적이지 않다. 진짜 배열처럼 이어져 있는게 아니고 포인트의 배열로 존재하고, 
각 포인터는 연속적인 배열을 가리키기 때문에 포인터배열의 인덱스가 자주바뀌면 캐시미스가 날 수 있기 때문이다.

vector<vector<bool>> 도 bool&를 반환하는 게 아니라 프록시객체를 반환하는 것이기 때문에(마치 진짜 bool인 것처럼 행동하는 가짜객체) 프록시 객체를 생성, 그 프록시 객체의 값을 참조하는 등 추가적인 오버헤드가 발생한다. 그러므로 vector<string>으로 0과1의 값을 받는 게 더 효율적이다. 

단지 코딩문제는 이런 효율보단 푸는 사람이 덜 실수하도록 하는 것이 중요하기 때문에 사용하는 것이다.

##복잡도

시간복잡도 둘다 동일하게 o(V + E) 이다.

왜냐하면 모든 정점과 간선을 한번씩 방문하기 때문이다.

여기서 E는 최대 V(V-1)까지 가능하다 (유향그래프의 경우,무향그래프는 2나누기)

공간복잡도 역시 동일하고 o(V) 이다.

방문여부를 체크하는 배열과 노드의 번호가 적혀있는 배열 모두 노드의 수만큼만 존재하기 때문이다.