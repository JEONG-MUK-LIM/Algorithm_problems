# 문제: 1197(최소 스패닝 트리)

그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.

최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.    

## 입력

첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.

그래프의 정점은 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 정점 사이에 경로가 있다. 최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.

## 출력

첫째 줄에 최소 스패닝 트리의 가중치를 출력한다.

## 해결방법

신장(스패닝) 트리란 모든 그래프의 정점을 빠짐없이 간선으로 잇되, 간선의 수가 최소만큼만 (즉 정점개수 - 1개만큼) 사용 되는 것을 의미한다.

또한 사이클이 존재하지 않는다.

신장트리는 여러개 존재할 수 있는데, 

최소 신장트리는 신장트리중에 모든 간선의 합이 최소가 되는 신장트리를 의미한다.

이를 구하기 위한 알고리즘은 프림알고리즘, 크루스칼 알고리즘이 있다.

이 문제는 프림 알고리즘을 사용했고, 크루스칼 알고리즘은 간선의 개수가 적은 경우, 프림알고리즘은 간선의 개수가 많은 경우에 적합하다.

<br/>
프림알고리즘은 다익스트라 알고리즘과 매우 유사하다.

다익스트라 알고리즘은 현재 우선순위 큐의 간선값과 다음 인접 노드로의 간선중 최솟값을 갖는 노드의 간선값의 합을 조건으로 이용하고 기록하지만, 프림 알고리즘은 매 순간 다음 인접노드중에 최솟값만의 간선을 기록하며(만약 필요하다면), visited로 해당 노드가 방문(신장트리로 연결)되었는지 체크하는 것이 조건이 된다. 

그리고 다익스트라 알고리즘은 먼저 기록 후 우선순위큐에 넣지만, 프림 알고리즘은 우선순위큐에 일단 넣고 top의 노드가 이미 방문했다면 continue, 아니라면 visited = true로 바꾸고 인접노드 확인을 하는 게 다른 점이다.

<br/>
크루스칼 알고리즘은 union - find 기법을 이용한다.

<br/>

먼저 union - find란 disjoint-set(서로소집합, 교집합이 없는 두 집합)을 이용하는 것으로 

여러개의 원소가 존재할 때, 이 원소들이 어떤 집합에 속해 있는지 파악하고 두 그룹을 합치는 연산을 효율적으로 진행한다.

각 집합에는 루트(id)가 존재하며 루트와의 비교로 각각 어떤 집합에 속해있는지 판단한다.

또한 집합내 루트가 다른 원소로 이어지지 않는다면 그 집합은 사이클이 존재하지 않음을 판단할 수 있다.

find(u) 함수로 u의 루트(id)를 리턴하고, union(u,v)로 u와 v를 같은 id를 갖는 트리로 합치게 된다.

union일때는 한 집합의 루트노드를 다른 집합의 루트노드로 바꿔놓기만 하고, 실제 루트노드의 변화는 find함수에서 바꿔준 다음 루트노드를 반환하게 된다. (필요할 때 연산을 진행하는 것을 lazy evaluation 이라고 함)

이때 find 함수에서 찾아가는 모든 노드의 부모를 한번에 대표노드로 바꿔준다. (경로압축,Path Compression)

경로 압축을 하지 않으면 매번 루트노드의 루트노드의.... 루트노드를 찾아야하므로 최악의 경우 find에 n번의 연산이 걸리는데, 한번 경로압축을 해놓으면 다음에는 o(1)에 찾을 수 있게 된다.

<br/>

크루스칼 알고리즘은 먼저 모든 간선 가중치를 기록하고 오름차순 정렬한다.

모든 정점은 자기 자신을 set id로 갖는다.

그 후 가장 작은 가중치를 갖는 간선을 선택한다.

그 간선의 시작점과 도착점을 파라미터로 union 함수를 호출해서 각각 setid를 find 하고 두 점의 set id가 같지 않다면 (사이클이 없다면)

해당 간선을 union한다. 즉 하나의 노드의 set id를 다른 쪽의 set id로 연결한다.

이때 최적화를 한다면 더 작은 트리(노드수가 작고, 트리가 더 낮은 쪽)을 더 큰 쪽에 붙이는 것이 좋지만 아무렇게나 연결해도 기능상 문제는 없다.

이런 식으로 v-1개의 간선을 선택한다면 최소신장트리를 구할 수 있다.

## 복잡도

프림 알고리즘의 복잡도는 o(Elog v)이다. 즉 dense한 경우에 크루스칼보다 더 유리하다.

크루스칼은 o(Elog E)이고 sparse 한 경우에 프림보다 유리하다.
