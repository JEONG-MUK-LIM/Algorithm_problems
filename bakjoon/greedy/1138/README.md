# 문제: 1138(한 줄로 서기)

N명의 사람들은 매일 아침 한 줄로 선다. 이 사람들은 자리를 마음대로 서지 못하고 오민식의 지시대로 선다.

어느 날 사람들은 오민식이 사람들이 줄 서는 위치를 기록해 놓는다는 것을 알았다. 그리고 아침에 자기가 기록해 놓은 것과 사람들이 줄을 선 위치가 맞는지 확인한다.

사람들은 자기보다 큰 사람이 왼쪽에 몇 명 있었는지만을 기억한다. N명의 사람이 있고, 사람들의 키는 1부터 N까지 모두 다르다.

각 사람들이 기억하는 정보가 주어질 때, 줄을 어떻게 서야 하는지 출력하는 프로그램을 작성하시오.     

## 입력

첫째 줄에 사람의 수 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 둘째 줄에는 키가 1인 사람부터 차례대로 자기보다 키가 큰 사람이 왼쪽에 몇 명이 있었는지 주어진다. i번째 수는 0보다 크거나 같고, N-i보다 작거나 같다. i는 0부터 시작한다.

## 출력

첫째 줄에 줄을 선 순서대로 키를 출력한다.

## 해결방법

글을 읽어서 이해하기 힘들 수 있으니 예제와 함께보아야 한다.
```
입력
4
2 1 1 0

출력 
4 2 1 3
```
입력 순서대로 키가 1 ~ n 인사람의 왼쪽에 자기보다 큰 사람이 있었던 사람의 수이다.

즉 키가 1인 사람의 왼쪽은 2명 자기보다 크므로 2

키가 2인 사람의 왼쪽은 1명 자기보다 크므로 1 이 되는 식이다.

수의 범위가 굉장히 작으므로 브루트포스를 사용해도 되지만,

생각해보면 그리디로 풀 수 있다.

먼저 키가 1인 사람이 받은 입력은 실제 순서의 인덱스가 된다.

왜냐하면 자기보다 모두 자기보다 크기 때문이다.

그런데 키가 2인 사람부터 문제가 생기는데 키가 1인사람도 염두에 두어야 하기 때문이다.

하지만 키가 1인 사람을 제외하고는 키가2인 사람도 모두 자기보다 크므로 이중 for문을 사용하여 

키가 1인 사람의 위치를 제외하고 나머지의 칸의 개수를 세면 된다.

빈칸을 가장 큰 키의 값으로 초기화해주고 값을 비교해주면서 현재보다 큰 경우 cnt를 1씩 더하고

cnt가 입력받은 값과 동일해지면서, 한번도 값이 바뀐적 없는 칸이라면 그 칸에 해당 키의 값을 넣어주면 된다  

## 복잡도

이중 for문이 필요하므로 o(n^2)의 시간복잡도를 갖는다.