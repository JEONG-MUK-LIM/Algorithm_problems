# 문제: 1080(행렬)

0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.

행렬을 변환하는 연산은 어떤 3×3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 → 1, 1 → 0)

## 입력

첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다

## 출력

첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.

## 해결방법

백트래킹문제나 bfs문제로 착각할 수 있다.

하지만 생각해보자. 2차원 배열의 한 원소는 0또는 1로, 내가 원하는 목표의 행렬과 같기위해서는 하나의 원소조차도 다르면 안된다.

그 말은 하나의 원소가 다르면 그 원소를 같게 만들어주기 위해서 무조건 뒤집기연산(xor연산)을 해주어야 한다는 것이다.

3x3 행렬의 크기만큼만 뒤집기 연산을 하므로 하나의 원소(3x3에서 가장 왼쪽 위)를 선택하고, 그 원소를 기준으로 뒤집기 연산을 하면 해당 원소는 앞으로 바뀔일이 없다. 

목표 행렬과 일치하기 때문이고, 앞으로 다른 데에서 뒤집기 연산을 해도 바뀔 일이 없기 때문이다.

그러므로 순서는 중요하지 않고, 각 일치하지 않는 위치마다 한번씩 뒤집기 연산을 해주는 것만이 가능하다.

이를 모든 원소에 대해 반복한 결과가 (정확하게는 n-3,m-3까지 )

내가 목표한 행렬과 일치하다면 만들 수 있는 것이고, 뒤집은 횟수만큼을 출력한다.

일치하지 않는다면 절대로 만들 수 없는 것이고, -1을 출력하면 된다.

이때 좌상단부터 바꾸기 시작한다는 결정이 그리디한 결정이기 때문에 그리디 알고리즘으로 분류하였다.


## 복잡도

뒤집기연산은 3x3만큼만하므로 상수시간으로 잡는다.

그러면 시간복잡도는 o(nm)