#문제:LCS(9251)

LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

##입력

첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

##출력

첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.

##해결방법

모든 경우의 수를 탐색하면 시간 내로 풀 수 없으므로 동적프로그래밍 기법을 사용해야한다.

문자열 일치 문제는 대체로 행렬을 사용해서 푸는 경우가 많으니 먼저 행렬을 이용해본다.

  C A P C A K P

A 0 0 0 0 0 0 0

C 0 0 0 0 0 0 0

A 0 0 0 0 0 0 0

Y 0 0 0 0 0 0 0

K 0 0 0 0 0 0 0

P 0 0 0 0 0 0 0

<br/>
여기서 해당 문자가 서로 일치하지 않는 경우 그대로 이전 행의 값과 이전 열의 값 중 큰 것을 선택해 가져오고, 일치 하는 경우  왼쪽 대각 위의 값을 가져오고 + 1 한다.

왼쪽 대각이 없는 경우는 0으로 가정함. 

이때 조건문을 만드는 것보다 행와 열의 크기를 +1씩해서 만드는 게 더 편하다.

반복문에서 문자열의 인덱스와 행렬의 인덱스를 주의한다.

  C A P C A K 
  
A 0 1 1 1 1 1 

C 1 1 1 2 2 2 

A 1 2 2 2 3 3 

Y 1 2 2 2 3 3 

K 1 2 2 2 3 4 

P 1 2 3 3 3 4

<br/>
이것이 왜 가능하냐면, 
<br/>
(i) 일치하지 않는 경우 

이전 행, 이전 열에서 최댓값을 뽑는 것은 

그 지점까지의 LCS를 가져와서 비교하는 것이기 때문이다.

예를 들면 (2,2) 인 A와 P에서의 비교를 할 때

(1,2) 에서 가져오는 최댓값인 2는 행에 해당하는 ACA와 열의 CA 를 비교한 것이고 (LCS는 CA, 즉 2)

(2,1) 에서 가져오는 최댓값인 1은 행의 AC와 열의 CAP를 비교한 것이다.

여기서 (2,2)에서는 두 문자인 A와 P가 일치하지 않으니 더 큰 CA를 가져온다.

그 결과 ACA와 CAP의 LCS는 CA가 된다.

<br/>
(ii) 일치하는 경우

(1,2)에서 ACA와 CA를 비교할 때 이전 행과 이전 열에서 가져오면

ACA와 C를 비교한 것에서 양쪽에 A를 추가하면 ACAA 와 CA를 비교한 게 되버리고, AC와 CA를 비교한 것에서 A를 추가하면 ACA와 CAA를 비교한 게 되버리니 이치에 맞지 않는다.

그러므로 AC와 C에서의 LCS를 가져오고, 거기에 A를 추가한다.


<br/>
추가로 LCS 자체를 구하는 법은 다음과 같다.

matrix[n][m]에서 시작, 문자가 일치하는 경우 lcs에 추가

일치하지 않는 경우 행과 열 중에 더 큰 쪽으로 이동한다. 둘의 숫자가 같다면 대각으로 이동

그리고 반복문이 끝나면 lcs를 거꾸로 출력한다.



##복잡도

각 문자의 크기를 n,m이라고 하면 행렬의 크기는 n X m 이고 그만큼의 배열만 사용했고, 반복했으므로 시간, 공간복잡도 모두 o(nm)이 된다.
